; This module bootstraps the ground environment with basic language facilities.
_

; construct a list from a sequence of values
(def list (wrap (op x _ x)))

; prepend a sequence of values to a list given as the final argument
(def list*
  (wrap
    (op args _
      (do
        (def aux
          (wrap
            (op ((head . tail)) _
              (if (empty? tail)
                head
                (cons head (aux tail))))))
        (aux args)))))

; return the first value in a pair
;
; Typically the head of a linked list.
(def first (wrap (op ((f . _)) _ f)))

; return the second value in a pair
;
; Typically the tail of a linked list.
(def rest (wrap (op ((_ . r)) _ r)))

; return the length of the given list
(def length
  (wrap
    (op (x) _
        (if (empty? x)
          0
          (+ 1 (length (rest x)))))))

; construct an operative
;
; An operative is a combiner that is called with unevaluated arguments and the
; caller's dynamic environment.
;
; Operatives are used to define new syntactic constructs.
(def op
  ((wrap
     (op (op) _
         (op (formals eformal . body) env
           (eval [op formals eformal
                  (if (> (length body) 1)
                    (cons do body)
                    (first body))]
                 env))))
   op))

; construct an operative and bind it to a symbol
;
; Returns the bound symbol. Write a comment before (defop) to provide
; documentation.
(def defop
  (op (name formals eformal . body) env
    (eval [def name [op formals eformal . body]] env)))

; construct a function
;
; Functions are applicative combiners which evaluate their arguments before
; passing them to an underlying operative.
(defop fn (formals . body) env
  (wrap (eval [op formals _ . body] env)))

; construct a function and bind it to a symbol
;
; Returns the bound symbol. Write a comment before (defn) to provide
; documentation.
(defop defn (name formals . body) env
  (eval [def name [fn formals . body]] env))

; return the second member of a linked list
(defn second [(_ x . _)]   x)

; return third member of a linked list
(defn third  [(_ _ x . _)] x)

; return the current environment
(defop get-current-env _ e e)

; returns the unevaluated form
(defop quote [x] _ x)

; returns a list containing the result of applying f to each member of xs
(def map
  (fn (f xs)
    (if (empty? xs)
      ()
      (cons (f (first xs))
            (map f (rest xs))))))

; calls a function with alternating pairs in a flat list (i.e. with pairs ungrouped)
;
; Takes 2-arity function and a flat pair sequence. Walks the sequence and calls
; f with 2 values at a time.
;
; Raises an error if the list has uneven length.
(defn map-pairs [f ps]
  (defn map-pairs-acc [f a ps]
    (if (empty? ps)
      (if (null? a)
        []
        (error "syntax: uneven pairs"))
      (if (null? a)
        (map-pairs-acc f (first ps) (rest ps))
        (cons (f a (first ps))
              (map-pairs-acc f null (rest ps))))))

  (map-pairs-acc f null ps))

; binds values in a child environment
;
; Takes a flat pair sequence alternating bindings and their values. Binds
; and evaluates each value in sequence, allowing later bindings to refer to
; earlier bindings.
;
; Returns the result of evaluating the body in the child environment.
(defop let (bindings . body) env
  (def child (make-env env))

  (map-pairs
    (fn [binding val]
      (eval [def binding val] child))
    bindings)

  (eval [do . body] child))

; provide bindings to the current scope from a nested scope
;
; Allows for modularity in code, selectively providing bindings while
; encapsulating bindings that they use.
(def provide
  (op [symbols . body] env
    (let [inner (make-env env)]
      (eval [do . body] inner)
      (map
        (fn [sym]
          (let [val (eval sym inner)
                com (eval [commentary sym] inner)]
            (eval [comment [def sym (eval sym inner)] com] env)
            sym))
        symbols))))

(provide [cond]
  (defn cond-pairs [f a ps]
    (if (empty? ps)
      (if (null? a)
        null
        uneven-pairs) ; TODO: proper error
      (if (null? a)
        (cond-pairs f (first ps) (rest ps))
        (do
          (def (ok . res) (f a (first ps)))
          (if ok
            res
            (cond-pairs f null (rest ps)))))))

  ; if-then-else with many clauses
  ;
  ; Takes a flat pair sequence alternating tests to evaluate and an
  ; expression to evaluate if the test returns a truthy value.
  ;
  ; Returns the result of the evaluated branch, or null if no tests were true.
  ;
  ; By convention, :else is used as the final catch-all test, though any
  ; truthy value works.
  (defop cond clauses env
    (cond-pairs
      (fn [test body]
        (if (eval test env)
          (cons true (eval body env))
          (cons false null)))
      null
      clauses)))

; lazily evaluated boolean 'or'
(defop or conds env
  (cond
    (empty? conds)
      false

    (= 1 (length conds))
      (first conds)

    :else
      (let [(x . xs) conds
            xv (eval x env)]
        (if xv
          xv
          (eval [or . xs] env)))))

; lazily evaluated boolean 'and'
(defop and conds env
  (cond
    (empty? conds)
      true

    (= 1 (length conds))
      (eval (first conds) env)

    :else
      (let [(x . xs) conds
            xv (eval x env)]
        (if xv
          (eval [and . xs] env)
          xv))))

; call an applicative's underlying operative with a list of arguments
;
; An environment may be provided as the third argument. If not specified, the
; operative will be called in a new empty environment.
;
; Used to call an applicative with pre-evaluated arguments, skipping the normal
; evaluation the applicative would perform prior to calling the underlying
; operative.
(defn apply [appv arg . opt]
  (eval (cons (unwrap appv) arg)
        (if (empty? opt)
          (make-env)
          (first opt))))

(provide (->)
  ; threads a value through forms
  ;
  ; Calls the first form with the given value, passing the result to the second
  ; form, and so on, returning the final value.
  ;
  ; A form may be a list or a single value. For a list, the value is inserted
  ; before the second value, becoming the first argument. For a single value,
  ; it is wrapped in a list with the value as the single argument.
  (defop -> [x f . fs] env
    (let [v (if (pair? f)
              (let [(f' . as) f]
                (eval [f' x . as] env))
              (eval [f x] env))]
      (if (empty? fs)
        v
        (eval [-> v . fs] env)))))

(provide (case)
  (defn case-branches [env val branches]
    (if (empty? branches)
      (errorf "no matching case branch: %s" val)
      (let [[pattern expr . rest] branches
            child (make-env env)]
        (if (bind child pattern val)
          (eval expr child)
          (case-branches env val rest)))))

  ; evaluates the branch that successfully binds the given value
  (defop case [v . bs] env
    (case-branches env (eval v env) bs)))

; idenity function; returns its argument
(defn id [x] x)
