; #!/usr/bin/env bass

; XXX: note to future self: this file is a messy stream of consciousness; the
; final decisions in terms of design are under demos/commands/

; usage: coverage <path/to/repo>
(def (repo) *args*)

; $ : path argv... kwargs? handler? => any
;   ; constructs and evaluates workload with args as argv
;
; bass : path stdin... handler? => any

; prototypes construct and evaluate workload with args as stdin, processed by a
; protocol; needs to be able to run a workload too
;
; add 'run : workload -> handler -> any'?
;
; $ runs directly, or respects runtime dispatch if a platform is configured
; prototypes process and then run

; don't have to write to /tmp, just trust that working directory is writable
($ .go "test" "-coverprofile" ./cover.out
   :from repo)

($ .go "tool" "cover" "-html" ./cover.out "-o" ./cover.html
   :from repo)

(run ($ .go "test" "-coverprofile" ./cover.out
        :from repo))

(run ($ .go "tool" "cover" "-html" ./cover.out "-o" ./cover.html
        :from repo))

(run {:args [.go "tool" "cover" "-html" ./cover.out "-o" ./cover.html]
      :from repo})

; instead of 'null', 'host: true'?
;
; would allow a system to forbid executing commands on the host by
; un-configuring it
(run {:native true}
     {:args [.go "tool" "cover" "-html" ./cover.out "-o" ./cover.html]
      :from repo})

(bass .check (fn [versions] (each versions log)))

(run {:platform {:os "linux"}
      :image {:repository "concourse/git-resource"}
      :args [/opt/resource/check]
      :stdin [{:source {:uri "https://github.com/vito/bass"}}]}
     (fn [versions] (each versions log)))

(run {:platform {:os "linux"
                 :image {:repository "concourse/git-resource"}}
      :args [/opt/resource/check]
      :stdin [{:source {:uri "https://github.com/vito/bass"}}]}
     (fn [versions] (each versions log)))

(run {:platform {:os "linux"}
      :context {:image {:repository "concourse/git-resource"}}
      :args [/opt/resource/check]
      :stdin [{:source {:uri "https://github.com/vito/bass"}}]}
     (fn [versions] (each versions log)))

(run {:os "linux"}
     {:image {:repository "concourse/git-resource"}
      :args [/opt/resource/check]
      :stdin [{:source {:uri "https://github.com/vito/bass"}}]}
     (fn [versions] (each versions log)))

(defn parse-cmdline-kwarg [cmdline key val]
  (cond
    ((= :in key)
     (assoc cmdline :in val))

    ((= :out key)
     (assoc cmdline :out val))

    (true
      (assoc cmdline :kwargs (assoc (:kwargs cmdline) key val)))))

; parses a commandline, extracting :in :out from kwargs and returning the
; remaining kwargs and args.
(defn parse-cmdline [cmdline cli]
  (cond
    [(empty? cli) cmdline]

    [(keyword? (first cli))
     (let [key (first cli)
           val (first (rest cli))
           clirest (rest (rest cli))]
       (extract-kwargs
         (process-cmdline-kwarg cmdline key val)
         clirest))]

    [true
     (extract-kwargs
       (assoc cmdline :args (append (:args cmdline) [(first cli)]))
       (rest cli))]))

(defn workload-cmdline [mixed]
  (parse-cmdline
    {:args []
     :kwargs {}
     :in null
     :out null}
    mixed))

(defn $ [cmd . args]
  (let [cmdline (workload-cmdline args)]
    (run {:host true}
         (assoc (:kwargs cmdline)
                :path cmd
                :args (cons (str cmd) (:args cmdline)))
         (:in cmdline)
         (:out cmdline))))

(defn concourse-resource [platform base source]
  (fn [cmd . args]
    (let [cmdline (workload-cmdline args)
          workload (cmd :stdin (:args cmdline))
          resource-workload (merge base (:workload cmdline))]
      (run platform
           (merge base resource-workload)
           (concourse-resource-protocol workload)
           (:in cmdline)
           (:out cmdline)))))

(def booklit
  (concourse-resource
    {:os "linux"}
    {:image {:repository "concourse/git-resource"}}
    {:uri "https://github.com/vito/booklit"}))

; it's weird for '$' and 'booklit' to behave differently
;
; is there ever a need to construct a thunk manually?
(run (booklit .check) (fn [versions] (each versions log)))

($ .go "list" "-json" "./..."
   :dir repo
   :out
   (fn [pkgs]
     ($ .jq ".Dir"
        :in pkgs
        :out (fn [dirs] (each dirs log)))))

=>

(run
  ($ .jq ".Dir"
     :stdin ($ .go "list" "-json" "./..." :dir repo))
  (fn [dirs] (each dirs log)))

(defn all [source]
  (let [n (next source _)]
    (if (ignore? n)
      []
      (cons n (all source)))))

($ .go "list" "-json" "./..." :from repo
   (fn [pkgs]
     ($ .jq ".Dir" :stdin (all pkgs)
        (fn [dirs]
          (each dirs log)))))

(pipe ($ .go "list" "-json" "./..." :from repo)
      ($ .jq ".Dir" (fn [dirs] (each dirs log))))

(pipe ($ .go "list" "-json" "./..." :from repo)
      ($ .jq ".Dir" (fn [dirs] (each dirs log))))

; $ : workload? [handler?]
(defn command args
  {:command args})

(defn in [dir workload]
  (new workload :from dir))

(defn $ [command . args]
  (new (command command) :stdin args))

($ (command-in repo (command .go "test" "-coverprofile" ./cover.out))))

($ (in repo (command .go)) "list" "-json" "./...")

($ (in repo (command .go "list" "-json" "./..."))
   (fn [list]
     ($ (.jq ".Dir")
        (fn [dirs]
          (each dirs log)))))

(pipe ($ (in repo (.go "list" "-json" "./...")))
      ($ (.jq ".Dir"))
      (fn [dirs] (each dirs log)))

($ .luakit ./cover.html)

; prototype can be dereferenced to get a combiner
; (@git .get bucket)

; (def bass {:uri "https://github.com/vito/bass"})

; makes caching results impossible on k8s, where 1 pod = 1 command
; (let [g @git]
;   (pipe [versions (g .check bass)
;          latest (g .get bass (last versions))]
;     (emit latest *stdout*)))

; prototype itself is a combiner for running commands
(def git
  ; raises an error if no appropriate runtime is found
  (runtime {:repository "concourse/git-resource"}
           :protocol "concourse-ci.org/resource"
           :platform {:os "linux"}))

(defn $ [command . args]
  (run (command :args args)))

; ~/.bass/runtimes.json:
;
(def platforms-json
  [{:platform {:os "linux"}
    :command "bass-docker"
    :config {:data-dir "~/.bass/data"}}])

(def linux
  {:os "linux"})

(defn git args
  (run (apply concourse-resource args)))
  {; platform should be a non-function object so that it can be sent over the
   ; wire and resolved to something else on the other side
   :platform linux

   ; protocol can be a function; it doesn't get sent over the wire
   :protocol concourse-resource

   :image {:repository "concourse/git-resource"}})

(def bass
  {:prototype git
   :uri "https://github.com/vito/bass"})

(defn git args
  (linux (apply concourse-resource args)))

(defn bass [command . args]
  (apply git [command {:uri "https://github.com/vito/bass"} . args]))

(git .get bucket)

; $ and git are 'command interpreters'?
;
; $ = host
;   * runs command in unique working directory
;     * unless a working directory is given?
;     * maybe bass scripts and prototypes do this?
;       * bass runs in empty working directory, only paths that are emitted are kept
;       * if nothing emitted, entire directory is cleaned up
