; #!/usr/bin/env bass

; usage: coverage <path/to/repo>
(def (repo) *args*)

; $ : path argv... kwargs? handler? => any
;   ; constructs and evaluates workload with args as argv
;
; bass : path stdin... handler? => any

; prototypes construct and evaluate workload with args as stdin, processed by a
; protocol; needs to be able to run a workload too
;
; add 'run : workload -> handler -> any'?
;
; $ runs directly, or respects runtime dispatch if a platform is configured
; prototypes process and then run

; don't have to write to /tmp, just trust that working directory is writable
($ .go "test" "-coverprofile" ./cover.out
   :from repo)

($ .go "tool" "cover" "-html" ./cover.out "-o" ./cover.html
   :from repo)

(defn all [source]
  (let [n (next source _)]
    (if (ignore? n)
      []
      (cons n (all source)))))

($ .go "list" "-json" "./..." :from repo
   (fn [pkgs]
     ($ .jq ".Dir" :stdin (all pkgs)
        (fn [dirs]
          (each dirs log)))))

(pipe ($ .go "list" "-json" "./..." :from repo)
      ($ .jq ".Dir" (fn [dirs] (each dirs log))))

(pipe ($ .go "list" "-json" "./..."
         :from repo)
      ($ .jq ".Dir" (fn [dirs] (each dirs log))))

; $ : workload? [handler?]
(defn command args
  {:command args})

(defn in [dir workload]
  (new workload :from dir))

(defn $ [command . args]
  (new (command command) :stdin args))

($ (command-in repo (command .go "test" "-coverprofile" ./cover.out))))

($ (in repo (command .go)) "list" "-json" "./...")

($ (in repo (command .go "list" "-json" "./..."))
   (fn [list]
     ($ (.jq ".Dir")
        (fn [dirs]
          (each dirs log)))))

(pipe ($ (in repo (.go "list" "-json" "./...")))
      ($ (.jq ".Dir"))
      (fn [dirs] (each dirs log)))

($ .luakit ./cover.html)

; prototype can be dereferenced to get a combiner
; (@git .get bucket)

; (def bass {:uri "https://github.com/vito/bass"})

; makes caching results impossible on k8s, where 1 pod = 1 command
; (let [g @git]
;   (pipe [versions (g .check bass)
;          latest (g .get bass (last versions))]
;     (emit latest *stdout*)))

; prototype itself is a combiner for running commands
(def git
  ; raises an error if no appropriate runtime is found
  (runtime {:repository "concourse/git-resource"}
           :protocol "concourse-ci.org/resource"
           :platform {:os "linux"}))

(git .get bucket)

; $ and git are 'command interpreters'?
;
; $ = host
;   * runs command in unique working directory
;     * unless a working directory is given?
;     * maybe bass scripts and prototypes do this?
;       * bass runs in empty working directory, only paths that are emitted are kept
;       * if nothing emitted, entire directory is cleaned up
