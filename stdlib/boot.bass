(def sequence
  ((wrap
     (op (seq2) _
         (seq2
           (def aux
             (op (head . tail) env
                 (if (empty? tail)
                   (eval head env)
                   (seq2
                     (eval head env)
                     (eval (cons aux tail) env)))))
           (op body env
               (if (empty? body)
                 null
                 (eval (cons aux body) env))))))
   (op (first second) env
       ((wrap (op _ _ (eval second env)))
        (eval first env)))))

(def list (wrap (op x _ x)))

(def list*
  (wrap
    (op args _
        (sequence
          (def aux
            (wrap
              (op ((head . tail)) _
                  (if (empty? tail)
                    head
                    (cons head (aux tail))))))
          (aux args)))))

(def car (wrap (op ((x . _)) _ x)))
(def cdr (wrap (op ((_ . butts)) _ butts)))

(def length
  (wrap
    (op (x) _
        (if (empty? x)
          0
          (+ 1 (length (cdr x)))))))

(def op
  ((wrap
     (op (op) _
         (op (formals eformal . body) env
             (eval (list op formals eformal
                         (if (>? (length body) 1)
                           (cons sequence body)
                           (car body))) env))))
   op))

(def fn
  (op (formals . body) env
      (wrap (eval (list* op formals _ body) env))))

(def caar (fn (((x . _) . _)) x))
(def cdar (fn (((_ . x) . _)) x))
(def cadr (fn ((_ . (x . _))) x))
(def cddr (fn ((_ . (_ . x))) x))

(def caaar (fn ((((x . _) . _) . _)) x))
(def cdaar (fn ((((_ . x) . _) . _)) x))
(def cadar (fn (((_ . (x . _)) . _)) x))
(def cddar (fn (((_ . (_ . x)) . _)) x))
(def caadr (fn ((_ . ((x . _) . _))) x))
(def cdadr (fn ((_ . ((_ . x) . _))) x))
(def caddr (fn ((_ . (_ . (x . _)))) x))
(def cdddr (fn ((_ . (_ . (_ . x)))) x))

(def caaaar (fn (((((x . _) . _) . _). _)) x))
(def cdaaar (fn (((((_ . x) . _) . _). _)) x))
(def cadaar (fn ((((_ . (x . _)) . _). _)) x))
(def cddaar (fn ((((_ . (_ . x)) . _). _)) x))
(def caadar (fn (((_ . ((x . _) . _)). _)) x))
(def cdadar (fn (((_ . ((_ . x) . _)). _)) x))
(def caddar (fn (((_ . (_ . (x . _))). _)) x))
(def cdddar (fn (((_ . (_ . (_ . x))). _)) x))
(def caaadr (fn ((_ .(((x . _) . _) . _))) x))
(def cdaadr (fn ((_ .(((_ . x) . _) . _))) x))
(def cadadr (fn ((_ .((_ . (x . _)) . _))) x))
(def cddadr (fn ((_ .((_ . (_ . x)) . _))) x))
(def caaddr (fn ((_ .(_ . ((x . _) . _)))) x))
(def cdaddr (fn ((_ .(_ . ((_ . x) . _)))) x))
(def cadddr (fn ((_ .(_ . (_ . (x . _))))) x))
(def cddddr (fn ((_ .(_ . (_ . (_ . x))))) x))

(def apply
  (fn (appv arg . opt)
    (eval (cons (unwrap appv) arg)
          (if (empty? opt)
            (make-environment)
            (car opt)))))

(def cond
  (op clauses env
      (def aux
        (fn ((test . body) . clauses)
          (if (eval test env)
            (apply (wrap sequence) body env)
            (apply (wrap cond) clauses env))))
      (if (empty? clauses)
        null
        (apply aux clauses))))

(def drop
  (fn (ls k)
    (if (>? k 0)
      (drop (cdr ls) (- k 1))
      ls)))

(def map
  (fn (f xs)
    (if (empty? xs)
      ()
      (cons (f (car xs)) (map f (cdr xs))))))

(def any?
  (fn (f xs)
    (cond
      ((empty? xs) false)
      ((f (car xs)) true)
      (true (any? f (cdr xs))))))

(def let
  (op (bindings . body) env
      (eval (cons (list* fn (map car bindings) body)
                  (map cadr bindings))
            env)))

(def zip
  (fn (f . xss)
    (let ((rest (map cdr xss)))
      (cons (apply f (map car xss))
            (if (any? empty? rest)
              ()
              (apply zip (cons f rest)))))))

(def not? (fn (x) (if x false true)))

(def and?
  (op xs e
      (cond
        ((empty? xs) true)
        ((eval (car xs) e) (apply (wrap and?) (cdr xs) e))
        (true false))))

(def or?
  (op xs e
      (cond
        ((empty? xs) false)
        ((eval (car xs) e) true)
        (true (apply (wrap or?) (cdr xs) e)))))

(def combiner?
  (fn xs
    (apply (wrap and?) (map (fn (x) (or? (operative? x) (applicative? x))) xs))))

(def at
  (fn (n xs)
    (car (drop n xs))))

(def reduce
  (fn (f xs a)
    (if (empty? xs)
      a
      (reduce f (cdr xs) (f a (car xs))))))

(def append
  (fn xss
    (def append2
      (fn (xs ys)
        (if (empty? xs)
          ys
          (cons (car xs) (append2 (cdr xs) ys)))))

    (reduce append2 xss ())))

(def list-neighbors
  (fn (xs)
    (if (>? (length xs) 1)
      (cons (list (car xs) (cadr xs)) (list-neighbors (cdr xs)))
      ())))

(def filter
  (fn (accept? xs)
    (if (empty? xs)
      ()
      (let (((a . bs) xs))
        (if (apply accept? (list a))
          (cons a (filter accept? bs))
          (filter accept? bs))))))

(def lookup
  (fn (n ps)
    (if (empty? ps)
      (cons false ())
      (let ((((k v) . rest) ps))
        (if (equal? n k)
          (cons true v)
          (lookup n rest))))))

(def member?
  (fn (x xs)
    (cond
      ((empty? xs) false)
      ((equal? x (car xs)) true)
      (true (member? x (cdr xs))))))

(def get-current-environment (wrap (op () e e)))

(def make-ground-static-environment
  (fn () (get-current-environment)))

(def ground (get-current-environment))

(def let*
  (op (bindings . body) env
      (eval (if (empty? bindings)
              (list* let bindings body)
              (list let (list (car bindings))
                    (list* let* (cdr bindings) body)))
            env)))

(def letrec
  (op (bindings . body) env
      (eval (list* let ()
                   (list def
                         (map car bindings)
                         (cons list (map cadr bindings)))
                   body)
            env)))

(def letrec*
  (op (bindings . body) env
      (eval (if (empty? bindings)
              (list* letrec bindings body)
              (list letrec (list (car bindings))
                    (list* letrec* (cdr bindings) body)))
            env)))

(def let-redirect
  (op (exp bindings . body) env
      (eval (cons (eval (list* fn (map car bindings) body) (eval exp env))
                  (map cadr bindings)) env)))

(def let-safe
  (op (bindings . body) env
      (eval (list* let-redirect
                   (make-hummus-static-environment)
                   bindings
                   body)
            env)))

(def remote-eval
  (op (o e) d
      (eval o (eval e d))))

(def bindings->environment
  (op bindings env
      (eval (list let-redirect
                  (make-environment)
                  bindings
                  (list get-current-environment))
            env)))

(def set!
  (op (target formals values) env
      (eval (list def formals (list (unwrap eval) values env))
            (eval target env))))

(def provide!
  (op (symbols . body) env
      (eval (list def symbols
                  (list let ()
                        (cons sequence body)
                        (cons list symbols)))
            env)))

(def import!
  (op (exp . symbols) env
      (eval (list set! env symbols (cons list symbols))
            (eval exp env))))

(def for-each
  (wrap (op (x f) env (apply map (list f x) env) null)))

(def defn
  (op (name . body) e
      (if (pair? name)
        (let (((n . as) name))
          (eval (list def n
                      (cons fn (cons as body)))
                e))
        (eval (cons def (cons name body)) e))))
